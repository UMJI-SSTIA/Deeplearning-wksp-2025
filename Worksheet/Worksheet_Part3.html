<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Worksheet_Part3</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<h1 id="注意力机制">注意力机制</h1>
<h2 id="生物学中的注意力提示">生物学中的注意力提示</h2>
<p>注意力是如何应用于视觉世界中的呢？
这要从当今十分普及的<em>双组件</em>（two-component）的框架开始讲起：
这个框架的出现可以追溯到19世纪90年代的威廉·詹姆斯，
他被认为是“美国心理学之父” 。
在这个框架中，受试者基于<em>非自主性提示</em>和<em>自主性提示</em>
有选择地引导注意力的焦点。</p>
<p>非自主性提示是基于环境中物体的突出性和易见性。
想象一下，假如我们面前有五个物品：
一份报纸、一篇研究论文、一杯咖啡、一本笔记本和一本书， 就像下图中。
所有纸制品都是黑白印刷的，但咖啡杯是红色的。
换句话说，这个咖啡杯在这种视觉环境中是突出和显眼的，
不由自主地引起人们的注意。 所以我们会把视力最敏锐的地方放到咖啡上，
如图所示。</p>
<figure>
<img src="../img/eye-coffee.svg"
alt="由于突出性的非自主性提示（红杯子），注意力不自主地指向了咖啡杯" />
<figcaption
aria-hidden="true">由于突出性的非自主性提示（红杯子），注意力不自主地指向了咖啡杯</figcaption>
</figure>
<p>喝咖啡后，我们会变得兴奋并想读书，
所以转过头，重新聚焦眼睛，然后看看书， 就像图中描述那样。
与前图中由于突出性导致的选择不同， 此时选择书是受到了认知和意识的控制，
因此注意力在基于自主性提示去辅助选择时将更为谨慎。
受试者的主观意愿推动，选择的力量也就更强大。</p>
<figure>
<img src="../img/eye-book.svg"
alt="依赖于任务的意志提示（想读一本书），注意力被自主引导到书上" />
<figcaption
aria-hidden="true">依赖于任务的意志提示（想读一本书），注意力被自主引导到书上</figcaption>
</figure>
<h2 id="查询键和值">查询、键和值</h2>
<p>自主性的与非自主性的注意力提示解释了人类的注意力的方式，
下面来看看如何通过这两种注意力提示，
用神经网络来设计注意力机制的框架，</p>
<p>首先，考虑一个相对简单的状况， 即只使用非自主性提示。
要想将选择偏向于感官输入， 则可以简单地使用参数化的全连接层，
甚至是非参数化的最大汇聚层或平均汇聚层。</p>
<p>因此，“是否包含自主性提示”将注意力机制与全连接层或汇聚层区别开来。
在注意力机制的背景下，自主性提示被称为<em>查询</em>（query）。
给定任何查询，注意力机制通过<em>注意力汇聚</em>（attention pooling）
将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。
在注意力机制中，这些感官输入被称为<em>值</em>（value）。
更通俗的解释，每个值都与一个<em>键</em>（key）配对，
这可以想象为感官输入的非自主提示。
如图所示，可以通过设计注意力汇聚的方式，
便于给定的查询（自主性提示）与键（非自主性提示）进行匹配，
这将引导得出最匹配的值（感官输入）。</p>
<figure>
<img src="../img/qkv.svg"
alt="注意力机制通过注意力汇聚将查询（自主性提示）和键（非自主性提示）结合在一起，实现对值（感官输入）的选择倾向" />
<figcaption
aria-hidden="true">注意力机制通过注意力汇聚将<em>查询</em>（自主性提示）和<em>键</em>（非自主性提示）结合在一起，实现对<em>值</em>（感官输入）的选择倾向</figcaption>
</figure>
<p>鉴于上面所提框架在图中的主导地位，
因此这个框架下的模型将成为本章的中心。
然而，注意力机制的设计有许多替代方案。
例如可以设计一个不可微的注意力模型，
该模型可以使用强化学习方法进行训练。</p>
<h2 id="注意力的可视化">注意力的可视化</h2>
<p>为了可视化注意力权重，需要定义一个<code>show_heatmaps</code>函数。
其输入<code>matrices</code>的形状是
（要显示的行数，要显示的列数，查询的数目，键的数目）。</p>
<p>下面使用一个简单的例子进行演示。
在本例子中，仅当查询和键相同时，注意力权重为1，否则为0。</p>
<figure>
<img src="../img/output_attention-cues_054b1a_33_1.svg" alt="heatmap" />
<figcaption aria-hidden="true">heatmap</figcaption>
</figure>
<h1 id="注意力汇聚nadaraya-watson-核回归">注意力汇聚：Nadaraya-Watson
核回归</h1>
<h2 id="平均汇聚">平均汇聚</h2>
<p>先使用最简单的估计器来解决回归问题。
基于平均汇聚来计算所有训练样本输出值的平均值：</p>
<p><span class="math display">\[f(x) = \frac{1}{n}\sum_{i=1}^n
y_i,\]</span></p>
<h2 id="非参数注意力汇聚">[<strong>非参数注意力汇聚</strong>]</h2>
<p>显然，平均汇聚忽略了输入 <span class="math inline">\(x_i\)</span> 。
于是Nadaraya和 Watson提出了一个更好的想法， 根据输入的位置对输出 <span
class="math inline">\(y_i\)</span> 进行加权：</p>
<p><span class="math display">\[f(x) = \sum_{i=1}^n \frac{K(x -
x_i)}{\sum_{j=1}^n K(x - x_j)} y_i,\]</span></p>
<p>其中 <span class="math inline">\(K\)</span> 是<em>核</em>（kernel）。
该公式所描述的估计器被称为 <em>Nadaraya-Watson核回归</em>。
这里不会深入讨论核函数的细节， 但受此启发，
我们可以从注意力机制框架的角度
重写一个更加通用的<em>注意力汇聚</em>（attention pooling）公式：</p>
<p><span class="math display">\[f(x) = \sum_{i=1}^n \alpha(x, x_i)
y_i,\]</span></p>
<p>其中 <span class="math inline">\(x\)</span> 是查询， <span
class="math inline">\((x_i, y_i)\)</span> 是键值对。
比较这两个注意力汇聚公式， 注意力汇聚是 <span
class="math inline">\(y_i\)</span> 的加权平均。 将查询 <span
class="math inline">\(x\)</span> 和键 <span
class="math inline">\(x_i\)</span> 之间的关系建模为
<em>注意力权重</em>（attention weight）<span
class="math inline">\(\alpha(x,x_i)\)</span> ，
这个权重将被分配给每一个对应值 <span class="math inline">\(y_i\)</span>
。 对于任何查询，模型在所有键值对注意力权重都是一个有效的概率分布：
它们是非负的，并且总和为1。</p>
<p>为了更好地理解注意力汇聚， 下面考虑一个<em>高斯核</em>（Gaussian
kernel），其定义为：</p>
<p><span class="math display">\[K(u) = \frac{1}{\sqrt{2\pi}}
\exp(-\frac{u^2}{2}).\]</span></p>
<p>将高斯核代入可以得到：</p>
<p><span class="math display">\[\begin{aligned} f(x) &amp;=\sum_{i=1}^n
\alpha(x, x_i) y_i\\ &amp;= \sum_{i=1}^n \frac{\exp\left(-\frac{1}{2}(x
- x_i)^2\right)}{\sum_{j=1}^n \exp\left(-\frac{1}{2}(x - x_j)^2\right)}
y_i \\ &amp;= \sum_{i=1}^n \mathrm{softmax}\left(-\frac{1}{2}(x -
x_i)^2\right) y_i. \end{aligned}\]</span></p>
<p>在这个公式中， 如果一个键 <span class="math inline">\(x_i\)</span>
越是接近给定的查询 <span class="math inline">\(x\)</span> ，
那么分配给这个键对应值 <span class="math inline">\(y_i\)</span>
的注意力权重就会越大， 也就“获得了更多的注意力”。</p>
<p>值得注意的是，Nadaraya-Watson核回归是一个非参数模型。
<em>非参数的注意力汇聚</em>（nonparametric attention pooling）模型。</p>
<h2 id="带参数注意力汇聚">[<strong>带参数注意力汇聚</strong>]</h2>
<p>非参数的Nadaraya-Watson核回归具有<em>一致性</em>（consistency）的优点：
如果有足够的数据，此模型会收敛到最优结果。
尽管如此，我们还是可以轻松地将可学习的参数集成到注意力汇聚中。</p>
<p>在下面的查询 <span class="math inline">\(x\)</span> 和键 <span
class="math inline">\(x_i\)</span> 之间的距离乘以可学习参数 <span
class="math inline">\(w\)</span> ：</p>
<p><span class="math display">\[\begin{aligned}f(x) &amp;= \sum_{i=1}^n
\alpha(x, x_i) y_i \\ &amp;= \sum_{i=1}^n
\frac{\exp\left(-\frac{1}{2}((x - x_i)w)^2\right)}{\sum_{j=1}^n
\exp\left(-\frac{1}{2}((x - x_j)w)^2\right)} y_i \\ &amp;= \sum_{i=1}^n
\mathrm{softmax}\left(-\frac{1}{2}((x - x_i)w)^2\right)
y_i.\end{aligned}\]</span></p>
<h3 id="批量矩阵乘法">批量矩阵乘法</h3>
<p>为了更有效地计算小批量数据的注意力，
我们可以利用深度学习开发框架中提供的批量矩阵乘法。</p>
<p>假设第一个小批量数据包含 <span class="math inline">\(n\)</span>
个矩阵 <span class="math inline">\(\mathbf{X}_1,\ldots,
\mathbf{X}_n\)</span> ， 形状为 <span class="math inline">\(a\times
b\)</span> ， 第二个小批量包含 <span class="math inline">\(n\)</span>
个矩阵 <span class="math inline">\(\mathbf{Y}_1, \ldots,
\mathbf{Y}_n\)</span> ， 形状为 <span class="math inline">\(b\times
c\)</span> 。 它们的批量矩阵乘法得到 <span
class="math inline">\(n\)</span> 个矩阵 <span
class="math inline">\(\mathbf{X}_1\mathbf{Y}_1, \ldots,
\mathbf{X}_n\mathbf{Y}_n\)</span>， 形状为 <span
class="math inline">\(a\times c\)</span> 。
因此，[<strong>假定两个张量的形状分别是 <span
class="math inline">\((n,a,b)\)</span> 和 <span
class="math inline">\((n,b,c)\)</span> ， 它们的批量矩阵乘法输出的形状为
<span class="math inline">\((n,a,c)\)</span> </strong>]。</p>
<h1 id="注意力评分函数">注意力评分函数</h1>
<p>使用高斯核来对查询和键之间的关系建模。
上面公式中的高斯核指数部分可以视为<em>注意力评分函数</em>（attention
scoring function）， 简称<em>评分函数</em>（scoring function），
然后把这个函数的输出结果输入到softmax函数中进行运算。
通过上述步骤，将得到与键对应的值的概率分布（即注意力权重）。
最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和。</p>
<p>从宏观来看，上述算法可以用来实现 注意力机制框架。 下图说明了
如何将注意力汇聚的输出计算成为值的加权和， 其中 <span
class="math inline">\(a\)</span> 表示注意力评分函数。
由于注意力权重是概率分布， 因此加权和其本质上是加权平均值。</p>
<figure>
<img src="../img/attention-output.svg"
alt="计算注意力汇聚的输出为值的加权和" />
<figcaption
aria-hidden="true">计算注意力汇聚的输出为值的加权和</figcaption>
</figure>
<p>用数学语言描述，假设有一个查询 <span class="math inline">\(\mathbf{q}
\in \mathbb{R}^q\)</span> 和 <span class="math inline">\(m\)</span>
个“键－值”对 <span class="math inline">\((\mathbf{k}_1, \mathbf{v}_1),
\ldots, (\mathbf{k}_m, \mathbf{v}_m)\)</span>， 其中 <span
class="math inline">\(\mathbf{k}_i \in \mathbb{R}^k\)</span> , <span
class="math inline">\(\mathbf{v}_i \in \mathbb{R}^v\)</span> 。
注意力汇聚函数 <span class="math inline">\(f\)</span>
就被表示成值的加权和：</p>
<p><span class="math display">\[
f(\mathbf{q}, (\mathbf{k}_1, \mathbf{v}_1), \ldots, (\mathbf{k}_m,
\mathbf{v}_m)) = \sum_{i=1}^m \alpha(\mathbf{q}, \mathbf{k}_i)
\mathbf{v}_i
\]</span> <span class="math display">\[
\text{where the output lies in } \mathbb{R}^v
\]</span></p>
<p>其中查询 <span class="math inline">\(\mathbf{q}\)</span> 和键 <span
class="math inline">\(\mathbf{k}_i\)</span> 的注意力权重（标量）
是通过注意力评分函数 <span class="math inline">\(a\)</span>
将两个向量映射成标量， 再经过softmax运算得到的：</p>
<p><span class="math display">\[
\alpha(\mathbf{q}, \mathbf{k}_i) = \mathrm{softmax}(a(\mathbf{q},
\mathbf{k}_i)) = \frac{\exp(a(\mathbf{q}, \mathbf{k}_i))}{\sum_{j=1}^m
\exp(a(\mathbf{q}, \mathbf{k}_j))}
\]</span> <span class="math display">\[
\text{where } \alpha(\mathbf{q}, \mathbf{k}_i) \in \mathbb{R}
\]</span></p>
<p>正如上图所示，选择不同的注意力评分函数 <span
class="math inline">\(a\)</span> 会导致不同的注意力汇聚操作。
这里将介绍两个流行的评分函数，稍后将用他们来实现更复杂的注意力机制。</p>
<h2 id="掩蔽softmax操作">[<strong>掩蔽softmax操作</strong>]</h2>
<p>正如上面提到的，softmax操作用于输出一个概率分布作为注意力权重。
在某些情况下，并非所有的值都应该被纳入到注意力汇聚中。
例如，为了高效处理小批量数据集，
某些文本序列被填充了没有意义的特殊词元。
为了仅将有意义的词元作为值来获取注意力汇聚，
可以指定一个有效序列长度（即词元的个数），
以便在计算softmax时过滤掉超出指定范围的位置。
下面的<code>masked_softmax</code>函数
实现了这样的<em>掩蔽softmax操作</em>（masked softmax operation），
其中任何超出有效长度的位置都被掩蔽并置为0。</p>
<p>为了[<strong>演示此函数是如何工作</strong>]的， 考虑由 <span
class="math inline">\(2 \times 2 \times 4\)</span> 张量表示的样本，
有效长度为 <span class="math inline">\([2,3]\)</span> 可以理解为 <span
class="math inline">\([[2,2],[3,3]]\)</span>
经过掩蔽softmax操作，超出有效长度的值都被掩蔽为0。</p>
<p>掩蔽后张量：</p>
<pre><code>[[[0.488994  , 0.511006  , 0.        , 0.        ],
[0.43654838, 0.56345165, 0.        , 0.        ]],

[[0.28817102, 0.3519408 , 0.3598882 , 0.        ],
[0.29034293, 0.25239873, 0.45725834, 0.        ]]]</code></pre>
<p>同样，也可以使用二维张量，为矩阵样本中的每一行指定有效长度。</p>
<p>若有效长度为 <span class="math inline">\([[1,3],[2,4]]\)</span> ,
那么掩蔽后张量：</p>
<pre><code>[[[1.        , 0.        , 0.        , 0.        ],
[0.35848376, 0.36588794, 0.2756283 , 0.        ]],

[[0.54370314, 0.45629686, 0.        , 0.        ],
[0.19598779, 0.25580424, 0.19916737, 0.34904057]]]</code></pre>
<h2 id="加性注意力">[<strong>加性注意力</strong>]</h2>
<p>一般来说，当查询和键是不同长度的矢量时，可以使用加性注意力作为评分函数。
给定查询 <span class="math inline">\(\mathbf{q} \in
\mathbb{R}^q\)</span> 和 键 <span class="math inline">\(\mathbf{k} \in
\mathbb{R}^k\)</span> ， <em>加性注意力</em>（additive
attention）的评分函数为</p>
<p><span class="math display">\[
a(\mathbf{q}, \mathbf{k}) = \mathbf{w}_v^\top \text{tanh}(\mathbf{W}_q
\mathbf{q} + \mathbf{W}_k \mathbf{k})  \text{where } a(\mathbf{q},
\mathbf{k}) \in \mathbb{R}
\]</span></p>
<p>其中可学习的参数是 <span class="math inline">\(\mathbf W_q\in\mathbb
R^{h\times q}\)</span> 、 <span class="math inline">\(\mathbf
W_k\in\mathbb R^{h\times k}\)</span> 和 <span
class="math inline">\(\mathbf w_v\in\mathbb R^{h}\)</span> 。
如公式所示， 将查询和键连结起来后输入到一个多层感知机（MLP）中，
感知机包含一个隐藏层，其隐藏单元数是一个超参数 <span
class="math inline">\(h\)</span> 。 通过使用 <span
class="math inline">\(\tanh\)</span> 作为激活函数。</p>
<h3 id="参数维度设置">参数维度设置</h3>
<p>在NLP(Natural Language Processing)中， 查询数小于等于第 <span
class="math inline">\(i\)</span> 个词元序列长度，且大于0， 而键 <span
class="math inline">\(k_i\)</span> 和值 <span
class="math inline">\(v_i\)</span> 数量通常就是第 <span
class="math inline">\(i\)</span> 个词元序列长度或者就是步数。</p>
<p>假设我们有一个序列 [“I”, “love”, “deep”, “learning”]， 你可能会只对词
“love” 提出查询。 此时，查询的长度为 1，而键的长度是 4（因为整个句子有 4
个词）。</p>
<p>在这种情况下， 查询 “love” 会与整个句子中的所有其他词（“I”, “love”,
“deep”, “learning”）进行比较， 得到它们之间的相似度（注意力分数），
然后计算加权和。</p>
<p><strong>query</strong>: (batch_size, num_q, feature_q)</p>
<p><strong>key</strong>: (batch_size, num_k&amp;v, feature_k)</p>
<p><strong>value</strong>: (batch_size, num_k&amp;v, feature_v)
(<strong>注意!</strong>查询、键和值各自的特征维度可以保持不同，此外，由于键值对的设置，键的数目和值的数目是一致的)</p>
<p><span class="math inline">\(W_q\)</span>:
一个线性层，输入维度是feature_q，输出维度是num_hidden,作用是将query的特征维度feature_q线性变换为num_hidden。</p>
<p>（此处的num_hidden代表的是query和key加和所使用的维度，由于最终注意力分数为标量，所以num_hidden是一个超参数，就像是被隐藏在这过程中）</p>
<p>剩下的 <span class="math inline">\(W_k\)</span> 与 <span
class="math inline">\(w_v\)</span> 同 <span
class="math inline">\(W_q\)</span> 有异曲同工之妙。</p>
<p><span class="math inline">\(W_k\)</span>:
一个线性层，输入维度是feature_k，输出维度是num_hidden</p>
<p><span class="math inline">\(w_v\)</span>:
一个线性层，输入维度是num_hidden，输出维度是1
(该层与value并无直接联系，故小写w)</p>
<p>随后可以计算 <span class="math inline">\(a(\mathbf q, \mathbf k) =
\mathbf w_v^\top \text{tanh}(\mathbf W_q\mathbf q + \mathbf W_k \mathbf
k) \text{, where }a(\mathbf q, \mathbf k)\in \mathbb{R},\)</span>
得到注意力分数，此时注意力分数张量是(batch_size, num_q, num_k&amp;v, 1),
最后一个维度可以去除，即张量为(batch_size, num_q, num_k&amp;v)</p>
<h3
id="对注意力分数进行masked_softmax">对注意力分数进行masked_softmax</h3>
<p><strong>valid_lens</strong>可以是一个 <span class="math inline">\(1
\times\)</span> batch_size的向量， 用于掩蔽掉一些注意力分数。</p>
<p>掩蔽之后对于各个注意力分数做softmax,使它们变成概率。</p>
<h3 id="计算注意力汇聚函数">计算注意力汇聚函数</h3>
<p><span class="math display">\[
f(\mathbf{q}, (\mathbf{k}_1, \mathbf{v}_1), \ldots, (\mathbf{k}_m,
\mathbf{v}_m)) = \sum_{i=1}^m \alpha(\mathbf{q}, \mathbf{k}_i)
\mathbf{v}_i \quad \text{where} \quad \mathbf{v}_i \in \mathbb{R}^v
\]</span></p>
<p>对于每一个批次，做value的加权求和，其中可以对某些注意力权重，也就是
<span class="math inline">\(\alpha(\mathbf{q}, \mathbf{k}_i)\)</span>
做暂退法dropout（把一些注意力权重设置成0）。</p>
<p>dropout是一种正则化技术，该技术的主要作用是防止神经网络的过拟合。</p>
<p>为了保证 Dropout
<strong>不会改变整体输出的期望</strong>，我们在训练时除以 <span
class="math inline">\(p\)</span> 进行缩放： <span
class="math display">\[\tilde{x} = \frac{x \cdot \mathbf{m}}{p}\]</span>
其中：</p>
<p><span class="math inline">\(\mathbf{m}\)</span>
是一个随机变量，满足： <span class="math display">\[\mathbf{m}
=  \begin{cases}  1, &amp; \text{概率 }  \\  0, &amp; \text{概率 } 1 -
p  \end{cases}\]</span></p>
<p>这样，我们计算缩放后的期望：</p>
<p><span class="math display">\[\mathbb{E}[\tilde{x}] = \mathbb{E}
\left[ \frac{x \cdot \mathbf{m}}{p} \right]
\]</span></p>
<p>因为 <strong>期望可以分配到乘法内</strong>，并且 <span
class="math inline">\(\mathbb{E}[\mathbf{m}] = p\)</span> ，所以：</p>
<p><span class="math display">\[
\mathbb{E}[\tilde{x}] = \frac{x}{p} \cdot \mathbb{E}[\mathbf{m}] =
\frac{x}{p} \cdot p = x
\]</span></p>
<p>这就证明了，即使我们随机丢弃了部分神经元，整体的期望值仍然保持不变**。</p>
<h3 id="进行批量矩阵乘法">进行批量矩阵乘法</h3>
<p>目前attention_weights张量大小是(batch_size, num_q, num_k&amp;v),
而values的形状是(batch_size, num_k&amp;v, feature_v)。</p>
<p>批量矩阵乘法(bmm)之后我们得到结果张量的形状是(batch_size, num_q,
feature_v)。</p>
<h3 id="例">例</h3>
<p>queries: Normal(0, 1, (2, 1, 20)) （(0，1）正态分布的张量) query_size
or feature_q=20</p>
<p>keys: Ones((2, 10, 2)) (由1填满的张量，代表了keys全部相同) key_size
or feature_k = 2</p>
<p>values: Arange(40, dtype=torch.float32).reshape(2, 10, 4)
（values的两个批次都是从0到40的张量 valid_lens: tensor([2, 6])</p>
<p>在计算过程中的超参数： num_hiddens=8, dropout=0.1</p>
<p>计算得出结果是一个 <span class="math inline">\(2 \times 1 \times
4\)</span> 的张量：</p>
<pre><code>[[[ 2.0000,  3.0000,  4.0000,  5.0000]],

[[10.0000, 11.0000, 12.0000, 13.0000]]]</code></pre>
<p>queries &amp; keys 热力图：</p>
<figure>
<img src="../img/output_attention-scoring-functions_addition.svg"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>尽管加性注意力包含了可学习的参数，但由于本例子中每个键都是相同的，
所以[<strong>注意力权重</strong>]是均匀的，由指定的有效长度决定。</p>
<h2 id="缩放点积注意力">[<strong>缩放点积注意力</strong>]</h2>
<p>使用点积可以得到计算效率更高的评分函数，
但是点积操作要求查询和键具有相同的长度 <span
class="math inline">\(d\)</span> 。
假设查询和键的所有元素都是独立的随机变量， 并且都满足零均值和单位方差，
那么两个向量的点积的均值为 <span class="math inline">\(0\)</span>
，方差为 <span class="math inline">\(d\)</span> 。
为确保无论向量长度如何， 点积的方差在不考虑向量长度的情况下仍然是<span
class="math inline">\(1\)</span>， 我们再将点积除以 <span
class="math inline">\(\sqrt{d}\)</span> ，
则<em>缩放点积注意力</em>（scaled dot-product
attention）评分函数为：</p>
<p><span class="math display">\[a(\mathbf q, \mathbf k) =
\mathbf{q}^\top \mathbf{k}  /\sqrt{d}.\]</span></p>
<p>在实践中，我们通常从小批量的角度来考虑提高效率， 例如基于 <span
class="math inline">\(n\)</span> 个查询和 <span
class="math inline">\(m\)</span> 个键－值对计算注意力，
其中查询和键的长度为 <span class="math inline">\(d\)</span> ，值的长度为
<span class="math inline">\(v\)</span> 。 查询 <span
class="math inline">\(\mathbf Q\in\mathbb R^{n\times d}\)</span> 、 键
<span class="math inline">\(\mathbf K\in\mathbb R^{m\times d}\)</span>
和 值 <span class="math inline">\(\mathbf V\in\mathbb R^{m\times
v}\)</span> 的缩放点积注意力是：</p>
<p><span class="math display">\[ \mathrm{softmax}\left(\frac{\mathbf Q
\mathbf K^\top }{\sqrt{d}}\right) \mathbf V \in \mathbb{R}^{n\times
v}.\]</span></p>
<p>与加性注意力演示相同，由于键包含的是相同的元素，
而这些元素无法通过任何查询进行区分，因此会获得[<strong>均匀的注意力权重</strong>]。</p>
<h1 id="多头注意力">多头注意力</h1>
<p>在实践中，当给定相同的查询、键和值的集合时，
我们希望模型可以基于相同的注意力机制学习到不同的行为，
然后将不同的行为作为知识组合起来， 捕获序列内各种范围的依赖关系
（例如，短距离依赖和长距离依赖关系）。
因此，允许注意力机制组合使用查询、键和值的不同
<em>子空间表示</em>（representation subspaces）可能是有益的。</p>
<p>为此，与其只使用单独一个注意力汇聚， 我们可以用独立学习得到的 <span
class="math inline">\(h\)</span> 组不同的 <em>线性投影</em>（linear
projections）来变换查询、键和值。 然后，这 <span
class="math inline">\(h\)</span>
组变换后的查询、键和值将并行地送到注意力汇聚中。 最后，将这 <span
class="math inline">\(h\)</span> 个注意力汇聚的输出拼接在一起，
并且通过另一个可以学习的线性投影进行变换， 以产生最终输出。
这种设计被称为<em>多头注意力</em>（multihead attention）。 对于 <span
class="math inline">\(h\)</span>
个注意力汇聚输出，每一个注意力汇聚都被称作一个<em>头</em>（head）。
下图展示了使用全连接层来实现可学习的线性变换的多头注意力。</p>
<figure>
<img src="../img/multi-head-attention.svg"
alt="多头注意力：多个头连结然后线性变换" />
<figcaption
aria-hidden="true">多头注意力：多个头连结然后线性变换</figcaption>
</figure>
<h2 id="数学模型">数学模型</h2>
<p>在实现多头注意力之前，让我们用数学语言将这个模型形式化地描述出来。
给定查询 <span class="math inline">\(\mathbf{q} \in
\mathbb{R}^{d_q}\)</span> 、 键 <span class="math inline">\(\mathbf{k}
\in \mathbb{R}^{d_k}\)</span> 和 值 <span
class="math inline">\(\mathbf{v} \in \mathbb{R}^{d_v}\)</span>，
每个注意力头<span class="math inline">\(\mathbf{h}_i\)</span>（<span
class="math inline">\(i = 1, \ldots, h\)</span>）的计算方法为：</p>
<p><span class="math display">\[\mathbf{h}_i = f(\mathbf
W_i^{(q)}\mathbf q, \mathbf W_i^{(k)}\mathbf k,\mathbf W_i^{(v)}\mathbf
v) \in \mathbb R^{p_v},\]</span></p>
<p>其中，可学习的参数包括 <span class="math inline">\(\mathbf
W_i^{(q)}\in\mathbb R^{p_q\times d_q}\)</span>、 <span
class="math inline">\(\mathbf W_i^{(k)}\in\mathbb R^{p_k\times
d_k}\)</span>和 <span class="math inline">\(\mathbf W_i^{(v)}\in\mathbb
R^{p_v\times d_v}\)</span>， 以及代表注意力汇聚的函数 <span
class="math inline">\(f\)</span> 。 <span
class="math inline">\(f\)</span>可以是 加性注意力和缩放点积注意力。
多头注意力的输出需要经过另一个线性转换， 它对应着 <span
class="math inline">\(h\)</span> 个头连结后的结果，因此其可学习参数是
<span class="math inline">\(\mathbf W_o\in\mathbb R^{p_o\times h
p_v}\)</span>：</p>
<p><span class="math display">\[
\mathbf{W_o} \begin{bmatrix}
\mathbf{h_1} \\
\vdots \\
\mathbf{h_h}
\end{bmatrix} \in \mathbb{R}^{p_o}
\]</span></p>
<p>基于这种设计，每个头都可能会关注输入的不同部分，
可以表示比简单加权平均值更复杂的函数。</p>
<h1 id="自注意力与位置编码">自注意力与位置编码</h1>
<p>在深度学习中，经常使用卷积神经网络（CNN）或循环神经网络（RNN）对序列进行编码。
想象一下，有了注意力机制之后，我们将词元序列输入注意力池化中，
以便同一组词元同时充当查询、键和值。
具体来说，每个查询都会关注所有的键－值对并生成一个注意力输出。
由于查询、键和值来自同一组输入，因此被称为
<em>自注意力</em>（self-attention）
也被称为<em>内部注意力</em>（intra-attention）</p>
<h2 id="自注意力">[<strong>自注意力</strong>]</h2>
<p>给定一个由词元组成的输入序列 <span
class="math inline">\(\mathbf{x}_1, \ldots, \mathbf{x}_n\)</span> ，
其中任意 <span class="math inline">\(\mathbf{x}_i \in
\mathbb{R}^d\)</span>（<span class="math inline">\(1 \leq i \leq
n\)</span>） 。 该序列的自注意力输出为一个长度相同的序列 <span
class="math inline">\(\mathbf{y}_1, \ldots, \mathbf{y}_n\)</span>
，其中：</p>
<p><span class="math display">\[\mathbf{y}_i = f(\mathbf{x}_i,
(\mathbf{x}_1, \mathbf{x}_1), \ldots, (\mathbf{x}_n, \mathbf{x}_n)) \in
\mathbb{R}^d\]</span></p>
<p>根据注意力汇聚函数 <span class="math inline">\(f\)</span> 。
对于一个翻译模型来说， query是目标语言的一个词元，
而keys和values是相同的，都是源语言的所有单词，
通过f函数可以计算出与query匹配度最高的翻译。</p>
<h2 id="位置编码">[<strong>位置编码</strong>]</h2>
<p>在处理词元序列时，循环神经网络是逐个的重复地处理词元的，
而自注意力则因为并行计算而放弃了顺序操作。
为了使用序列的顺序信息，通过在输入表示中添加
<em>位置编码</em>（positional encoding）来注入绝对的或相对的位置信息。
位置编码可以通过学习得到也可以直接固定得到。
接下来描述的是基于正弦函数和余弦函数的固定位置编码</p>
<p>假设输入表示 <span class="math inline">\(\mathbf{X} \in \mathbb{R}^{n
\times d}\)</span> 包含一个序列中<span
class="math inline">\(n\)</span>个词元的<span
class="math inline">\(d\)</span>维嵌入表示。
位置编码使用相同形状的位置嵌入矩阵 <span
class="math inline">\(\mathbf{P} \in \mathbb{R}^{n \times d}\)</span>
输出 <span class="math inline">\(\mathbf{X} + \mathbf{P}\)</span> ，
矩阵第 <span class="math inline">\(i\)</span> 行、第 <span
class="math inline">\(2j\)</span> 列和 <span
class="math inline">\(2j+1\)</span> 列上的元素为：</p>
<p><span class="math display">\[
\begin{aligned}
p_{i, 2j} &amp;= \sin\left(\frac{i}{10000^{2j/d}}\right), \\
p_{i, 2j+1} &amp;= \cos\left(\frac{i}{10000^{2j/d}}\right).
\end{aligned}
\]</span></p>
<h3 id="绝对位置信息">绝对位置信息</h3>
<p>乍一看，这种基于三角函数的设计看起来很奇怪。</p>
<p>要解释这个设计，首先我们要理解绝对位置信息和沿着编码维度单调降低的频率。即绝对位置信息同三角函数中随着j的增加，波的频率下降的关系。</p>
<h4 id="以二进制为例">以二进制为例</h4>
<table>
<thead>
<tr>
<th>位置索引 ( pos )</th>
<th>二进制表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
</tr>
<tr>
<td>11</td>
<td>1011</td>
</tr>
<tr>
<td>12</td>
<td>1100</td>
</tr>
<tr>
<td>13</td>
<td>1101</td>
</tr>
<tr>
<td>14</td>
<td>1110</td>
</tr>
<tr>
<td>15</td>
<td>1111</td>
</tr>
</tbody>
</table>
<p>现在我们再来理解基于三角函数设计的绝对位置信息</p>
<figure>
<img
src="../img/output_self-attention-and-positional-encoding_d76d5a_52_0.svg"
alt="绝对位置信息" />
<figcaption aria-hidden="true">绝对位置信息</figcaption>
</figure>
<h3 id="相对位置信息">相对位置信息</h3>
<p>除了捕获绝对位置信息之外，上述的位置编码还允许模型学习得到输入序列中相对位置信息。
这是因为对于任何确定的位置偏移<span
class="math inline">\(\delta\)</span>，位置<span class="math inline">\(i
+ \delta\)</span>处 的位置编码可以线性投影位置<span
class="math inline">\(i\)</span>处的位置编码来表示。</p>
<p>这种投影的数学解释是，令<span class="math inline">\(\omega_j =
1/10000^{2j/d}\)</span>， 对于任何确定的位置偏移<span
class="math inline">\(\delta\)</span>， 任何一对 <span
class="math inline">\((p_{i, 2j}, p_{i, 2j+1})\)</span> 都可以线性投影到
<span class="math inline">\((p_{i+\delta, 2j}, p_{i+\delta,
2j+1})\)</span>：</p>
<p><span class="math display">\[\begin{aligned}
&amp;\begin{bmatrix} \cos(\delta \omega_j) &amp; \sin(\delta \omega_j)
\\  -\sin(\delta \omega_j) &amp; \cos(\delta \omega_j) \\ \end{bmatrix}
\begin{bmatrix} p_{i, 2j} \\  p_{i, 2j+1} \\ \end{bmatrix}\\
=&amp;\begin{bmatrix} \cos(\delta \omega_j) \sin(i \omega_j) +
\sin(\delta \omega_j) \cos(i \omega_j) \\  -\sin(\delta \omega_j) \sin(i
\omega_j) + \cos(\delta \omega_j) \cos(i \omega_j) \\ \end{bmatrix}\\
=&amp;\begin{bmatrix} \sin\left((i+\delta) \omega_j\right)
\\  \cos\left((i+\delta) \omega_j\right) \\ \end{bmatrix}\\
=&amp;
\begin{bmatrix} p_{i+\delta, 2j} \\  p_{i+\delta, 2j+1} \\
\end{bmatrix},
\end{aligned}\]</span></p>
<p><span class="math inline">\(2\times 2\)</span>
投影矩阵不依赖于任何位置的索引 <span class="math inline">\(i\)</span>
。</p>
<h1 id="transformer">Transformer</h1>
<p>Transformer作为编码器－解码器架构的一个实例，其整体架构在下图中展示。正如所见到的，Transformer的编码器和解码器是基于自注意力的模块叠加而成的，源（输入）序列和目标（输出）序列的<em>嵌入</em>（embedding）表示将加上<em>位置编码</em>（positional
encoding），再分别输入到编码器和解码器中。</p>
<figure>
<img src="../img/transformer.svg" alt="transformer架构" />
<figcaption aria-hidden="true">transformer架构</figcaption>
</figure>
<p>从宏观角度来看，Transformer的编码器是由多个相同的层叠加而成的，每个层都有两个子层（子层表示为<span
class="math inline">\(\mathrm{sublayer}\)</span>）。第一个子层是<em>多头自注意力</em>（multi-head
self-attention）汇聚；第二个子层是<em>基于位置的前馈网络</em>（positionwise
feed-forward
network）。具体来说，在计算编码器的自注意力时，查询、键和值都来自前一个编码器层的输出。受残差网络的启发，每个子层都采用了<em>残差连接</em>（residual
connection）。在Transformer中，对于序列中任何位置的任何输入<span
class="math inline">\(\mathbf{x} \in
\mathbb{R}^d\)</span>，都要求满足<span
class="math inline">\(\mathrm{sublayer}(\mathbf{x}) \in
\mathbb{R}^d\)</span>，以便残差连接满足<span
class="math inline">\(\mathbf{x} + \mathrm{sublayer}(\mathbf{x}) \in
\mathbb{R}^d\)</span>。在残差连接的加法计算之后，紧接着应用<em>层规范化</em>（layer
normalization）。因此，输入序列对应的每个位置，Transformer编码器都将输出一个<span
class="math inline">\(d\)</span>维表示向量。</p>
<p>Transformer解码器也是由多个相同的层叠加而成的，并且层中使用了残差连接和层规范化。除了编码器中描述的两个子层之外，解码器还在这两个子层之间插入了第三个子层，称为<em>编码器－解码器注意力</em>（encoder-decoder
attention）层。在编码器－解码器注意力中，查询来自前一个解码器层的输出，而键和值来自整个编码器的输出。在解码器自注意力中，查询、键和值都来自上一个解码器层的输出。但是，解码器中的每个位置只能考虑该位置之前的所有位置。这种<em>掩蔽</em>（masked）注意力保留了<em>自回归</em>（auto-regressive）属性，确保预测仅依赖于已生成的输出词元。</p>
<h2 id="基于位置的前馈网络">[<strong>基于位置的前馈网络</strong>]</h2>
<p>基于位置的前馈网络对序列中的所有位置的输入进行变换时使用的是同一个多层感知机（MLP），和其他位置的输入没有任何关系，这就是称前馈网络是<em>基于位置的</em>（positionwise）的原因。在下面的实现中，输入<code>X</code>的形状（批量大小，时间步数或序列长度，隐单元数或特征维度）将被一个两层的感知机转换成形状为（批量大小，时间步数，<code>ffn_num_outputs</code>）的输出张量。</p>
<p>第一层全连接：该层将输入的每个位置的向量从 <strong>特征维度</strong>
映射到 <strong>隐藏层维度</strong>，经过一个线性变换。</p>
<p>激活函数：然后应用一个非线性激活函数，ReLU，来增加模型的非线性能力。</p>
<p>ReLU (Rectified Linear Unit) 的公式为：</p>
<p><span class="math display">\[
\text{ReLU}(x) = \max(0, x)
\]</span></p>
<p>这意味着如果输入 $ x $ 为负数，则输出为 0；如果输入 $ x $
为正数，则输出为 $ x $ 本身。</p>
<p>第二层全连接：接着通过第二个全连接层将隐藏层的维度从
<strong>隐藏层维度</strong> 映射到
<code>ffn_num_outputs</code>（通常是与输入的特征维度相同）。</p>
<h2 id="残差连接和层规范化">[<strong>残差连接和层规范化</strong>]</h2>
<p>现在让我们关注
<em>加法和规范化</em>（add&amp;norm）组件。这是由残差连接和紧随其后的层规范化组成的。两者都是构建有效的深度架构的关键。</p>
<p>层规范化的作用是将一个特征维度进行规范化：
计算平均值，计算方差，最终通过线性变换使得它们符合正态分布。</p>
<p>给定张量 ( X )：</p>
<p><span class="math display">\[
X = \begin{bmatrix} 1 &amp; 2 \\ 2 &amp; 3 \end{bmatrix}
\]</span></p>
<h3 id="残差连接-的操作"><strong>残差连接</strong> 的操作</h3>
<p>核心思想是：每一层的输出不仅仅依赖于当前层的计算结果，还与输入通过直接的加法操作相结合，这样可以使网络更容易训练。</p>
<p>具体的操作是：对输出张量Y做dropout正则化，然后与输入张量X相加，这也要求了输出张量和输入张量的形状相同。</p>
<p>残差连接有助于缓解 梯度消失 和 梯度爆炸
问题，并促进更深层次的网络训练。具体来说：</p>
<ol type="1">
<li>在传统的深层网络中，随着网络的深度增加，梯度可能会变得非常小或非常大，导致训练变得困难。而残差连接通过
直接传递梯度（通过加法）来缓解这个问题。</li>
<li>由于直接传递了 输入的信息（即
X），即使某一层的计算表现不佳，网络也能通过残差连接保留一些有效的信息，有助于更好的学习。</li>
</ol>
<h3 id="层规范化-的操作"><strong>层规范化</strong> 的操作</h3>
<p><code>LayerNorm(2)</code> 表示对于每一行的 2
个特征维度（即每个样本的特征），进行标准化处理。</p>
<p>标准化的公式为：</p>
<p><span class="math display">\[
X_{\text{normalized}} = \frac{X - \mu}{\sigma}
\]</span></p>
<p>其中： - <span class="math inline">\(\mu\)</span> 是该行的均值， -
<span class="math inline">\(\sigma\)</span> 是该行的标准差。</p>
<p>我们分别对每一行进行计算。</p>
<hr />
<h3 id="第一行1-2-的计算"><strong>第一行：[1, 2]</strong> 的计算：</h3>
<ol type="1">
<li><strong>均值</strong> ( <span class="math inline">\(\mu_1\)</span>
)：</li>
</ol>
<p><span class="math display">\[
\mu_1 = \frac{1 + 2}{2} = 1.5
\]</span></p>
<ol start="2" type="1">
<li><strong>标准差</strong> ( <span
class="math inline">\(\sigma_1\)</span> )：</li>
</ol>
<p><span class="math display">\[
\sigma_1 = \sqrt{\frac{(1 - 1.5)^2 + (2 - 1.5)^2}{2}} = \sqrt{\frac{0.25
+ 0.25}{2}} = \sqrt{0.25} = 0.5
\]</span></p>
<ol start="3" type="1">
<li><strong>标准化</strong>：</li>
</ol>
<p><span class="math display">\[
X_{\text{normalized}} = \frac{[1, 2] - 1.5}{0.5} = \left[\frac{1 -
1.5}{0.5}, \frac{2 - 1.5}{0.5}\right] = [-1, 1]
\]</span></p>
<hr />
<h3 id="第二行2-3-的计算"><strong>第二行：[2, 3]</strong> 的计算：</h3>
<ol type="1">
<li><strong>均值</strong> ( <span class="math inline">\(\mu_2\)</span>
)：</li>
</ol>
<p><span class="math display">\[
\mu_2 = \frac{2 + 3}{2} = 2.5
\]</span></p>
<ol start="2" type="1">
<li><strong>标准差</strong> ( <span
class="math inline">\(\sigma_2\)</span> )：</li>
</ol>
<p><span class="math display">\[
\sigma_2 = \sqrt{\frac{(2 - 2.5)^2 + (3 - 2.5)^2}{2}} = \sqrt{\frac{0.25
+ 0.25}{2}} = \sqrt{0.25} = 0.5
\]</span></p>
<ol start="3" type="1">
<li><strong>标准化</strong>：</li>
</ol>
<p><span class="math display">\[
X_{\text{normalized}} = \frac{[2, 3] - 2.5}{0.5} = \left[\frac{2 -
2.5}{0.5}, \frac{3 - 2.5}{0.5}\right] = [-1, 1]
\]</span></p>
<hr />
<h3 id="最终的标准化结果"><strong>最终的标准化结果</strong></h3>
<p>标准化后的矩阵 <span
class="math inline">\(X_{\text{normalized}}\)</span> 为：</p>
<p><span class="math display">\[
X_{\text{normalized}} = \begin{bmatrix}
-1 &amp; 1 \\
-1 &amp; 1 \\
\end{bmatrix}
\]</span></p>
<h3 id="addnorm">AddNorm</h3>
<p>将残差连接和层规范化结合起来</p>
<p><span class="math display">\[
\text{Output} = \text{LayerNorm}(\text{Dropout}(Y) + X)
\]</span></p>
<h2 id="编码器">编码器</h2>
<p>有了组成Transformer编码器的基础组件，现在可以先[<strong>实现编码器中的一个层</strong>]。下面的<code>EncoderBlock</code>类包含两个子层：多头自注意力和基于位置的前馈网络，这两个子层都使用了残差连接和紧随的层规范化。</p>
<h3 id="encoder-block">Encoder Block</h3>
<ol type="1">
<li><p><strong>Multi-head Attention</strong>：</p>
<p>多头注意力机制可以通过多个注意力头并行计算，然后将它们的结果拼接起来，最终通过一个线性变换得到输出。多头注意力可以表示为：</p>
<p><span class="math display">\[\text{MultiHeadAttention}(Q, K, V) =
\text{Concat}(head_1, head_2, \dots, head_h)W^O\]</span></p>
<p>其中，<span class="math inline">\(h\)</span> 是头的数量，<span
class="math inline">\(Q, K, V\)</span> 是查询、键、值矩阵，<span
class="math inline">\(W^O\)</span>
是输出的线性变换矩阵。每个注意力头的计算如下：</p>
<p><span class="math display">\[head_i = \text{Attention}(QW_i^Q,
KW_i^K, VW_i^V)\]</span></p>
<p>其中，<span class="math inline">\(W_i^Q\)</span> , <span
class="math inline">\(W_i^K\)</span> , <span
class="math inline">\(W_i^V\)</span> 是每个头的参数, <span
class="math inline">\(\text{Attention}(Q, K, V)\)</span>
是标准的缩放点积注意力。</p>
<p>缩放点积注意力公式为：</p>
<p><span class="math display">\[\text{Attention}(Q, K, V) =
\text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V\]</span></p>
<p>其中, <span class="math inline">\(d_k\)</span> 是键的维度。</p></li>
<li><p><strong>AddNorm 1</strong>：</p>
<p>对于第一个规范化操作，假设 <span class="math inline">\(X\)</span>
为输入， <span class="math inline">\(\text{MultiHeadAttention}(X, X,
X)\)</span> 为通过多头注意力计算得到的输出，规范化步骤为：</p>
<p><span class="math display">\[ Y_1 = \text{AddNorm}(X,
\text{MultiHeadAttention}(X, X, X)) \]</span></p>
<p>这里，<code>AddNorm</code> 表示加法和归一化操作。</p></li>
<li><p><strong>Feed-Forward Network</strong>：</p>
<p>在前馈神经网络中，我们先对输入 <span
class="math inline">\(Y_1\)</span>
应用一个全连接层，然后进行非线性激活，最后再经过一个全连接层：</p>
<p><span class="math display">\[ \text{FFN}(Y_1) = \text{ReLU}(Y_1W_1 +
b_1)W_2 + b_2 \]</span></p>
<p>其中，<span class="math inline">\(W_1\)</span> , <span
class="math inline">\(W_2\)</span> 是权重矩阵，<span
class="math inline">\(b_1\)</span> , <span
class="math inline">\(b_2\)</span> 是偏置, <span
class="math inline">\(\text{ReLU}\)</span> 是激活函数。</p></li>
<li><p><strong>AddNorm 2</strong>：</p>
<p>对于第二个规范化操作，最终输出是：</p>
<p><span class="math display">\[Y_2 = \text{AddNorm}(Y_1,
\text{FFN}(Y_1))\]</span></p></li>
<li><p><strong>最终输出</strong>：</p>
<p>所以，Encoder Block的输出可以表示为：</p>
<p><span class="math display">\[\text{EncoderBlock}(X) =
\text{AddNorm}(\text{AddNorm}(X, \text{MultiHeadAttention}(X, X, X)),
\text{FFN}(\text{AddNorm}(X, \text{MultiHeadAttention}(X, X,
X))))\]</span></p></li>
</ol>
<h3 id="transformer-编码器的组成">Transformer 编码器的组成</h3>
<p>编码器首先将输入的词元转化为嵌入表示，然后通过
<strong>位置编码</strong>
加入词元的位置信息。由于Transformer没有卷积或递归结构，位置编码非常关键，它为每个词元添加了关于词元相对位置的信息。</p>
<p><span class="math display">\[
X = \text{Embedding}(X) + \text{PositionalEncoding}(X)
\]</span></p>
<p>然后X会通过多个 Encoder 块， 每个 Encoder
块都会接收上一层的输出作为输入。</p>
<p>经过所有的 Encoder 块后，最后一个 Encoder 块的输出就是
编码器的最终输出，这些输出将被传递给解码器。</p>
<h2 id="解码器">解码器</h2>
<p>[<strong>Transformer解码器也是由多个相同的层组成</strong>]。在<code>DecoderBlock</code>类中实现的每个层包含了三个子层：解码器自注意力、“编码器-解码器”注意力和基于位置的前馈网络。这些子层也都被残差连接和紧随的层规范化围绕。</p>
<p>在掩蔽多头解码器自注意力层（第一个子层）中，查询、键和值都来自上一个解码器层的输出。关于<em>序列到序列模型</em>（sequence-to-sequence
model），在训练阶段，其输出序列的所有位置（时间步）的词元都是已知的；然而，在预测阶段，其输出序列的词元是逐个生成的。因此，在任何解码器时间步中，只有生成的词元才能用于解码器的自注意力计算中。为了在解码器中保留自回归的属性，其掩蔽自注意力设定了参数<code>dec_valid_lens</code>，以便任何查询都只会与解码器中所有已经生成词元的位置（即直到该查询位置为止）进行注意力计算。</p>
<p><code>DecoderBlock</code> 是解码器中的第 i
个块，负责生成目标序列的输出。该块通过自注意力和编码器-解码器注意力机制来进行序列建模。</p>
<h3 id="输入参数">输入参数</h3>
<ul>
<li><strong><code>X</code></strong>：解码器的输入（目标序列的词元表示）。形状为
<code>(batch_size, num_steps, d)</code>，其中 <code>d</code>
是词元的维度。</li>
<li><strong><code>state</code></strong>：包含三个部分的元组：
<ul>
<li><code>state[0]</code>：编码器的输出，形状为
<code>(batch_size, num_steps, num_hiddens)</code>。</li>
<li><code>state[1]</code>：编码器的有效长度，形状为
<code>(batch_size,)</code> 或
<code>(batch_size, num_steps)</code>。</li>
<li><code>state[2]</code>：解码器的内部状态，用于缓存解码过程中的输出表示。</li>
</ul></li>
</ul>
<h3 id="初始化-key_values">1. 初始化 <code>key_values</code></h3>
<p>解码器在训练和推理阶段的行为不同。在训练时，所有的词元会在同一时间步进行处理，因此
<code>state[2][self.i]</code> 初始化为
<code>None</code>。在推理时，解码是一个个时间步逐步进行的，<code>state[2][self.i]</code>
会缓存到目前为止生成的解码器输出。</p>
<p><span class="math display">\[
key\_values =
\begin{cases}
X &amp; \text{if } state[2][self.i] \text{ is None} \\
\text{concatenate}(state[2][self.i], X) &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p><strong>在推理的过程中</strong> <span
class="math inline">\(\text{concatenate}\)</span>
的作用是将当前解码器块（self.i）的输出 state[2][self.i]
和当前时间步的输入 X（查询）
拼接在一起。这意味着，当前解码器块将使用之前生成的解码结果和当前时刻的输入来计算当前时刻的输出。例如，如果
<span class="math inline">\(state[2][self.i] = (batch_size, 1,
d)\)</span>
，那么key_values会是X和state[2][self.i]拼接变成形状(batch_size, 2,
d)，依旧可以通过复制X（查询）的方式和当前时间步形状为（batch_size,
1,d）的X（查询）进行注意力分数的计算。</p>
<h3 id="生成解码器的有效长度-dec_valid_lens">2. 生成解码器的有效长度
(<code>dec_valid_lens</code>)</h3>
<p>在训练时，<code>dec_valid_lens</code> 是一个从 1 到
<code>num_steps</code>
的序列，用来表示每个查询的有效长度。该有效长度用于计算自注意力时的掩码（masking）。在推理时，<code>dec_valid_lens</code>
设为 <code>None</code>，因为解码是逐步进行的。</p>
<p><span class="math display">\[
dec\_valid\_lens = \text{arange}(1, num\_steps + 1) \quad
\text{(训练阶段)}
\]</span></p>
<p>基于
dec_valid_lens，我们可以构造出一个掩码（mask），以防止模型在自注意力中访问到不应该访问的未来信息。具体来说，我们可以根据
dec_valid_lens 来标记哪些位置是“有效”的，哪些位置是“无效”的。</p>
<h3 id="自注意力self-attention">3. 自注意力（Self-Attention）</h3>
<p>自注意力机制通过查询、键和值来计算每个位置的注意力权重，并加权求和得到每个位置的表示。自注意力的计算公式为：</p>
<p><span class="math display">\[
Q = X, \quad K = V = key\_values
\]</span></p>
<p>自注意力的输出 <span class="math inline">\(X_2\)</span>
通过点积计算注意力分数，进行缩放，最后通过 softmax
获取注意力权重，然后加权求和得到结果：</p>
<p><span class="math display">\[
X_2 = \text{Attention}(Q, K, V)
\]</span></p>
<p>然后，添加残差连接并进行层归一化：</p>
<p><span class="math display">\[
Y = \text{AddNorm}(X, X_2)
\]</span></p>
<h3 id="编码器-解码器注意力encoder-decoder-attention">4.
编码器-解码器注意力（Encoder-Decoder Attention）</h3>
<p>编码器-解码器注意力通过将解码器的输出 <code>Y</code> 与编码器的输出
<code>enc_outputs</code> 进行交互来计算注意力。其公式为：</p>
<p><span class="math display">\[
Q = Y, \quad K = V = enc\_outputs
\]</span></p>
<p>编码器-解码器注意力的输出 <span class="math inline">\(Y_2\)</span>
同样通过点积计算注意力分数，进行缩放，最后通过 softmax
获取注意力权重，进行加权求和：</p>
<p><span class="math display">\[
Y_2 = \text{Attention}(Q, K, V)
\]</span></p>
<p>然后，添加残差连接并进行层归一化：</p>
<p><span class="math display">\[
Z = \text{AddNorm}(Y, Y_2)
\]</span></p>
<h3 id="前馈神经网络feedforward-network">5. 前馈神经网络（FeedForward
Network）</h3>
<p>最后，通过前馈神经网络对输出 <span class="math inline">\(Z\)</span>
进行处理，得到最终的输出：</p>
<p><span class="math display">\[
\text{Output} = \text{AddNorm}(Z, \text{FFN}(Z))
\]</span></p>
<h3 id="最终输出">最终输出</h3>
<p><code>DecoderBlock</code>
的输出是经过前馈神经网络处理后的结果，以及更新后的
<code>state</code>，其中 <code>state[2]</code>
缓存了当前块解码后的输出。</p>
<h2 id="transformer-解码器">Transformer 解码器</h2>
<h3 id="输入嵌入input-embedding">输入嵌入（Input Embedding）</h3>
<p>解码器的输入是目标序列的词元，在训练阶段，它们是已知的，而在推理阶段，它们是逐步生成的。在每个时间步，解码器会根据之前的词元生成当前时间步的输出。</p>
<p>词元嵌入：首先，目标序列的每个词元被转换为一个嵌入向量，嵌入向量的维度通常与编码器的输出维度（d）相同。
位置编码：然后，目标序列的嵌入向量与相应的位置编码相加，位置编码用于提供关于词元在序列中位置的信息。</p>
<h3
id="输入进入解码器块entering-decoder-block">输入进入解码器块（Entering
Decoder Block）：</h3>
<p>输入的嵌入向量（加上位置编码后的目标序列）将进入多个
解码器块（Decoder Block）。
每个解码器块的输出将作为下一个解码器块的输入，最终得到解码器的输出。</p>
<h3 id="生成预测prediction-generation">生成预测（Prediction
Generation）：</h3>
<p>解码器的最终输出将用于生成目标序列的下一个词元的概率分布。
在训练阶段，解码器通过当前的输出和目标序列生成下一个词元的预测。
在推理阶段，解码器逐步生成目标序列中的词元。</p>
</body>
</html>
